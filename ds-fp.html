<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: 데이터 과학</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="Software Carpentry Blog" href="http://software-carpentry.org/feed.xml"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    
      ga('create', 'UA-59802572-19', 'auto');
      ga('send', 'pageview');
    
    </script>
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="http://software-carpentry.org" title="Software Carpentry">
          <img alt="Software Carpentry banner" src="img/software-carpentry-banner.png" />
        </a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <a href="index.html"><h1 class="title">데이터 과학</h1></a>
          <h2 class="subtitle">함수형 프로그래밍(Functional Programming)</h2>
          <h1 id="r-functional-programming">함수형 프로그래밍</h1>
<p>데이터 과학 맥락에서 함수형 프로그래밍을 이해하고, 수치해석 예제를 통해 코드를 작성하고, 함수형 프로그래밍과 짝꿍인 단위 테스트에 대해서 살펴본다.</p>
<p><strong>함수형 프로그래밍(functional programming)</strong>은 코드를 작성하는 한 방식으로 특정 연산을 수행하는 함수를 먼저 작성하고 나서, 사용자가 함수를 호출해서 작업을 수행하는 방식이다. 순수 함수형 언어, 예를 들어 <a href="https://ko.wikipedia.org/wiki/하스켈">하스케(Haskell)</a>은 루프가 없다. 루푸없이 어떻게 프로그램을 작성할 수 있을까? 루프는 재귀(recursion)로 대체된다. 이런 이유로 아래에서 뉴톤 방법을 통해 근을 구하는 방식을 R코드로 두가지 방법을 보여준다. R은 아직 <a href="http://hanmomhanda.github.io/2015/07/27/%EC%9E%AC%EA%B7%80-%EB%B0%98%EB%B3%B5-Tail-Recursion/">꼬리 호출(tail-call recurssion)</a> 기능을 제공하지 않기 때문에 루프를 사용하는 것이 더 낫다.</p>
<p>수학 함수는 멋진 특성이 있는데, 즉 해당 입력에 항상 동일한 결과를 갖는다. 이 특성을 <strong>참조 투명성(referential transparaency)</strong> 이라고 부른다. 참조 투명성은 <strong>부수효과(side effect)</strong> 없음을 표현하는 속성인데, 함수가 결과값 외에 다른 상태를 변경시킬 때 부수효과(side effect)가 있다고 한다. 부수 효과는 프로그램 버그를 발생시키는 온상으로, 부수 효과를 없애면 디버깅이 용이해진다. 따라서, 부수 효과를 제거하고 참조 투명성을 유지함으로써 데이터 분석 수행 결과를 예측 가능한 상태로 유지시켜 <strong>재현가능한 과학</strong>이 가능하게 된다.</p>
<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 10px;}
</style>
<div class="blue">
<p><strong>함수형 프로그래밍</strong></p>
<p>R 함수형 프로그래밍을 이해하기 위해서는 먼저 자료구조에 대한 이해가 선행되어야 한다. 그리고 나서, 함수를 작성하는 이유와 더불어 작성법에 대한 이해도 확고히 해야만 한다.</p>
<p>객체(object)가 함수를 갖는 데이터라면, 클러져는 데이터를 갖는 함수다.</p>
<blockquote>
<p>“An object is data with functions. A closure is a function with data.” – John D. Cook</p>
</blockquote>
</div>
<p>명령형 언어(Imperative Language) 방식으로 R코드를 쭉 작성하게 되면, 각 단계별로 상태가 변경되는 것에 대해 신경을 쓰고 관리를 해나가야 된다. 그렇지 않으면 예기치 않은 부수 효과가 발생하여 데이터 분석 및 모형을 잘못 해석하게 된다.</p>
<p>그렇다고, 부수효과가 없는 순수 함수가 반듯이 좋은 것은 아니다. 예를 들어 <code>rnorm()</code> 함수를 통해 평균 0, 분산 1인 난수를 생성시키는데, 항상 동일한 값만 뽑아내면 사용자에게 의미있는 함수는 아니다.</p>
<p>결국, 함수형 프로그래밍을 통해 <strong>테스팅(testing)</strong>과 <strong>디버깅(debugging)</strong>을 수월하게 하는 것이 추구하는 바이다. 이를 위해 다음 3가지 요인이 중요하다.</p>
<ul>
<li>한번에 한가지 작업을 수행하는 함수</li>
<li>부수효과(side effect) 회피</li>
<li>참조 투명성(Referential transparaency)</li>
</ul>
<h2 id="why-functional-programming">왜 함수형 프로그래밍인가?</h2>
<p>데이터 분석을 아주 추상화해서 간략하게 얘기한다면 데이터프레임을 함수에 넣어 새로운 데이터프레임으로 만들어 내는 것이다.</p>
<p><img src="fig/fp-data-analysis.png" alt="데이터 분석 추상화" width="77%" /></p>
<p>데이터 분석, 데이터 전처리, 변수 선택, 모형 개발이 한번에 해결되는 것이 아니라서, 데이터프레임을 함수에 넣어 상태가 변경된 데이터프레임이 생성되고, 이를 다시 함수에 넣어 또다른 변경된 상태 데이터프레임을 얻게 되는 과정을 쭉 반복해 나간다.</p>
<p><img src="fig/fp-data-analysis-workflow.png" alt="데이터 분석 작업흐름" width="37%" /></p>
<p>따라서… 데이터 분석에는 함수형 프로그래밍 패러다임을 활용하고, 툴/패키지 개발에는 객체지향 프로그래밍 패러다임 사용이 권장된다.</p>
<p><img src="fig/fp-data-analysis-choice.png" alt="데이터 분석에는 함수형 프로그래밍" width="77%" /></p>
<h2 id="functional-programming-newton"><a href="https://en.wikipedia.org/wiki/Newton%27s_method">뉴튼 방법(Newton’s Method)</a></h2>
<p>뉴튼-랩슨 알고리즘으로도 알려진 뉴튼(Newton Method) 방법은 컴퓨터를 사용해서 수치해석 방법으로 실함수의 근을 찾아내는 방법이다.</p>
<p>특정 함수 <span class="math inline">\(f\)</span> 의 근을 찾을 경우, 함수 미분값 <span class="math inline">\(f&#39;\)</span>, 초기값 <span class="math inline">\(x_0\)</span>가 주어지면 근사적 근에 가까운 값은 다음과 같이 정의된다.</p>
<p><span class="math display">\[x_{1} = x_0 - \frac{f(x_0)}{f&#39;(x_0)}\]</span></p>
<p>이 과정을 반복하게 되면 오차가 매우 적게 근의 값에 도달하게 된다.</p>
<p><span class="math display">\[x_{n+1} = x_n - \frac{f(x_n)}{f&#39;(x_n)}\]</span></p>
<p>기하적으로 보면, 파란 선은 함수 <span class="math inline">\(f\)</span> 이고, <span class="math inline">\(f\)</span>를 미분한 <span class="math inline">\(f&#39;\)</span> 빨간 선은 뉴턴방법을 활용하여 근을 구해가는 과정을 시각적으로 보여주고 있다. <span class="math inline">\(x_{n-1}\)</span> 보다 <span class="math inline">\(x_n\)</span>이, <span class="math inline">\(x_n\)</span> 보다 <span class="math inline">\(x_{n+1}\)</span>이 함수 <span class="math inline">\(f\)</span> 근에 더 가깝게 접근해 나가는 것이 확인된다.</p>
<p><img src="fig/newton_method_ani.gif" alt="뉴튼 방법" width="57%" /></p>
<h2 id="functional-programming-newton-method">뉴튼 방법 R 코드 <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></h2>
<p>뉴튼 방법을 R코들 구현하면 다음과 같이 612의 제곱근 값을 수치적으로 컴퓨터를 활용하여 구할 수 있다. <code>while</code>같은 루프를 활용하여 반복적으로 해를 구하는 것도 가능하지만 재귀를 활용하여 해를 구하는 방법이 코드를 작성하고 읽는 개발자 관점에서는 훨씬 더 편리하고 권장된다.</p>
<p>하지만, 속도는 <code>while</code> 루프를 사용하는 것이 R에서는 득이 많다. 이유는 오랜 세월에 걸쳐 최적화 과정을 거쳐 진화했기 때문이다.</p>
<div class="row">
<div class="col-md-6">
<p><strong>while 루프를 사용한 방법</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">find_root &lt;-<span class="st"> </span><span class="cf">function</span>(guess, init, <span class="dt">eps =</span> <span class="dv">10</span><span class="op">^</span>(<span class="op">-</span><span class="dv">10</span>)){
    <span class="cf">while</span>(<span class="kw">abs</span>(init<span class="op">**</span><span class="dv">2</span> <span class="op">-</span><span class="st"> </span>guess) <span class="op">&gt;</span><span class="st"> </span>eps){
        init &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span><span class="dv">2</span> <span class="op">*</span>(init <span class="op">+</span><span class="st"> </span>guess<span class="op">/</span>init)
        <span class="kw">cat</span>(<span class="st">&quot;현재 값: &quot;</span>, init, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    }
    <span class="kw">return</span>(init)
}

<span class="kw">find_root</span>(<span class="dv">612</span>, <span class="dv">10</span>)</code></pre></div>
<pre><code>현재 값:  35.6 
현재 값:  26.39551 
현재 값:  24.79064 
현재 값:  24.73869 
현재 값:  24.73863 
현재 값:  24.73863 </code></pre>
<pre><code>[1] 24.73863</code></pre>
</div>
<div class="col-md-6">
<p><strong>재귀를 사용한 방법</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">find_root_recur &lt;-<span class="st"> </span><span class="cf">function</span>(guess, init, <span class="dt">eps =</span> <span class="dv">10</span><span class="op">^</span>(<span class="op">-</span><span class="dv">10</span>)){
    <span class="cf">if</span>(<span class="kw">abs</span>(init<span class="op">**</span><span class="dv">2</span> <span class="op">-</span><span class="st"> </span>guess) <span class="op">&lt;</span><span class="st"> </span>eps){
        <span class="kw">return</span>(init)
    } <span class="cf">else</span>{
        init &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span><span class="dv">2</span> <span class="op">*</span>(init <span class="op">+</span><span class="st"> </span>guess<span class="op">/</span>init)
        <span class="kw">cat</span>(<span class="st">&quot;재귀방법 현재 값: &quot;</span>, init, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
        <span class="kw">return</span>(<span class="kw">find_root_recur</span>(guess, init, eps))
    }
}

<span class="kw">find_root_recur</span>(<span class="dv">612</span>, <span class="dv">10</span>)</code></pre></div>
<pre><code>재귀방법 현재 값:  35.6 
재귀방법 현재 값:  26.39551 
재귀방법 현재 값:  24.79064 
재귀방법 현재 값:  24.73869 
재귀방법 현재 값:  24.73863 
재귀방법 현재 값:  24.73863 </code></pre>
<pre><code>[1] 24.73863</code></pre>
</div>
</div>
<h1 id="map-reduce-apply"><code>Map()</code>, <code>Reduce()</code> 함수와 <code>*apply()</code> 함수 가족 <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></h1>
<p>함수를 인자로 받는 함수를 고차함수(High-order function)라고 부른다. 대표적으로 <code>Map()</code>, <code>Reduce()</code>가 있다. 숫자 하나가 아닌 벡터에 대한 제곱근을 구하기 위해서 <code>Map</code> 함수를 사용한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 제곱근 함수 -------------------------------------------</span>

find_root_recur &lt;-<span class="st"> </span><span class="cf">function</span>(guess, init, <span class="dt">eps =</span> <span class="dv">10</span><span class="op">^</span>(<span class="op">-</span><span class="dv">10</span>)){
    <span class="cf">if</span>(<span class="kw">abs</span>(init<span class="op">**</span><span class="dv">2</span> <span class="op">-</span><span class="st"> </span>guess) <span class="op">&lt;</span><span class="st"> </span>eps){
        <span class="kw">return</span>(init)
    } <span class="cf">else</span>{
        init &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span><span class="dv">2</span> <span class="op">*</span>(init <span class="op">+</span><span class="st"> </span>guess<span class="op">/</span>init)
        <span class="kw">return</span>(<span class="kw">find_root_recur</span>(guess, init, eps))
    }
}

<span class="co"># 벡터에 대한 제곱근 계산 </span>

numbers &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">16</span>, <span class="dv">25</span>, <span class="dv">36</span>, <span class="dv">49</span>, <span class="dv">64</span>, <span class="dv">81</span>)
<span class="kw">Map</span>(find_root_recur, numbers, <span class="dt">init=</span><span class="dv">1</span>, <span class="dt">eps =</span> <span class="dv">10</span><span class="op">^-</span><span class="dv">10</span>)</code></pre></div>
<pre><code>[[1]]
[1] 4

[[2]]
[1] 5

[[3]]
[1] 6

[[4]]
[1] 7

[[5]]
[1] 8

[[6]]
[1] 9</code></pre>
<p>숫자 하나를 받는 함수가 아니라, 벡터를 인자로 받아 제곱근을 계산하는 함수를 작성할 경우 함수 내부에서 함수를 인자로 받을 수 있도록 <code>Map</code> 함수를 활용한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># `Map` 벡터 제곱근 계산</span>

find_vec_root_recur &lt;-<span class="st"> </span><span class="cf">function</span>(numbers, init, <span class="dt">eps =</span> <span class="dv">10</span><span class="op">^</span>(<span class="op">-</span><span class="dv">10</span>)){
    <span class="kw">return</span>(<span class="kw">Map</span>(find_root_recur, numbers, init, eps))
}

numbers_z &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">9</span>, <span class="dv">16</span>, <span class="dv">25</span>, <span class="dv">49</span>, <span class="dv">121</span>)
<span class="kw">find_vec_root_recur</span>(numbers_z, <span class="dt">init=</span><span class="dv">1</span>, <span class="dt">eps=</span><span class="dv">10</span><span class="op">^</span>(<span class="op">-</span><span class="dv">10</span>))</code></pre></div>
<pre><code>[[1]]
[1] 3

[[2]]
[1] 4

[[3]]
[1] 5

[[4]]
[1] 7

[[5]]
[1] 11</code></pre>
<p>이러한 패턴이 많이 활용되어 <code>*apply</code> 함수가 있어, 이전에 많이 사용했을 것이다. 벡터를 인자로 먼저 넣고, 함수명을 두번째 인자로 넣고, 함수에 들어갈 매개변수를 순서대로 쭉 나열하여 <code>lapply</code>, <code>sapply</code> 함수에 넣는다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># `lapply` 활용 제급근 계산</span>

<span class="kw">lapply</span>(numbers_z, find_root_recur, <span class="dt">init=</span><span class="dv">1</span>, <span class="dt">eps=</span><span class="dv">10</span><span class="op">^</span>(<span class="op">-</span><span class="dv">10</span>))</code></pre></div>
<pre><code>[[1]]
[1] 3

[[2]]
[1] 4

[[3]]
[1] 5

[[4]]
[1] 7

[[5]]
[1] 11</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sapply</span>(numbers_z, find_root_recur, <span class="dt">init=</span><span class="dv">1</span>, <span class="dt">eps=</span><span class="dv">10</span><span class="op">^</span>(<span class="op">-</span><span class="dv">10</span>))</code></pre></div>
<pre><code>[1]  3  4  5  7 11</code></pre>
<p><code>Reduce</code> 함수도 삶을 편안하게 할 수 있는, 루프를 회피하는 또다른 방법이다. 이름에서 알 수 있듯이 <code>numbers_z</code> 벡터 원소 각각에 대해 해당 연산작업 <code>+</code>, <code>%%</code>을 수행시킨다. <code>%%</code>는 나머지 연산자로 기본디폴트 설정으로 <span class="math inline">\(\frac{10}{7}\)</span>로 몫 대신에 나머지 3을 우선 계산하고, 그 다음으로 <span class="math inline">\(\frac{3}{5}\)</span>로 최종 나머지 3을 순차적으로 계산하여 결과를 도출한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Reduce ----------------------------------------------</span>
numbers_z</code></pre></div>
<pre><code>[1]   9  16  25  49 121</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Reduce</span>(<span class="st">`</span><span class="dt">+</span><span class="st">`</span>, numbers_z)</code></pre></div>
<pre><code>[1] 220</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">numbers_z &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">10</span>,<span class="dv">7</span>,<span class="dv">5</span>)
<span class="kw">Reduce</span>(<span class="st">`</span><span class="dt">%%</span><span class="st">`</span>, numbers_z)</code></pre></div>
<pre><code>[1] 3</code></pre>
<h1 id="functional-programming-purrr"><code>purrr</code> 팩키지</h1>
<p><code>*apply</code> 계열 함수는 각각의 자료형에 맞춰 기억하기가 쉽지 않아, 매번 도움말을 찾아 확인하고 코딩을 해야하는 번거러움이 많다. 데이터 분석을 함수형 프로그래밍 패러다임으로 실행하도록 <code>purrr</code> 팩키지가 개발되었다. 이를 통해 데이터 분석 작업이 수월하게 되어 저녁이 있는 삶이 길어질 것으로 기대된다.</p>
<h2 id="functional-programming-purrr-hello-world"><code>purrr</code> 헬로월드</h2>
<p><code>purrr</code> 팩키지를 불러와서 <code>map_dbl()</code> 함수에 구문에 맞게 작성하면 동일한 결과를 깔끔하게 얻을 수 있다. 즉,</p>
<ul>
<li><code>map_dbl()</code>: 벡터, 데이터프레임, 리스트에 대해 함수를 원소별로 적용시켜 결과를 <code>double</code> 숫자형으로 출력시킨다.</li>
<li><code>numbers</code>: 함수를 각 원소별로 적용시킬 벡터 입력값</li>
<li><code>find_root_recur</code>: 앞서 작성한 뉴톤 방법으로 제곱근을 수치적으로 구하는 사용자 정의함수.</li>
<li><code>init=1, eps = 10^-10</code>: 뉴톤 방법을 구현한 사용자 정의함수에 필요한 초기값.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(purrr)
numbers &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">16</span>, <span class="dv">25</span>, <span class="dv">36</span>, <span class="dv">49</span>, <span class="dv">64</span>, <span class="dv">81</span>)
<span class="kw">map_dbl</span>(numbers, find_root_recur, <span class="dt">init=</span><span class="dv">1</span>, <span class="dt">eps =</span> <span class="dv">10</span><span class="op">^-</span><span class="dv">10</span>)</code></pre></div>
<pre><code>[1] 4 5 6 7 8 9</code></pre>
<h2 id="functional-programming-purrr-read-iris">데이터 불러오는 사례</h2>
<p>구글 검색을 통해서 쉽게 <a href="https://gist.githubusercontent.com/curran/a08a1080b88344b0c8a7/raw/d546eaee765268bf2f487608c537c05e22e4b221/iris.csv">iris(붓꽃) 데이터</a>를 구할 수 있다. 이를 불러와서 각 종별로 <code>setosa</code> <code>versicolor</code>, <code>virginica</code>로 나눠 로컬 <code>.csv</code> 파일로 저장하고 나서 이를 다시 불러오는 사례를 함수형 프로그래밍으로 구현해본다.</p>
<p><img src="fig/fp-iris.png" alt="붓꽃 데이터 불러오기" width="100%" /></p>
<p>먼저 <code>iris.csv</code> 파일을 R로 불러와서 각 종별로 나눠서 <code>iris_종명.csv</code> 파일형식으로 저장시킨다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)
iris_df &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;https://gist.githubusercontent.com/curran/a08a1080b88344b0c8a7/raw/d546eaee765268bf2f487608c537c05e22e4b221/iris.csv&quot;</span>)

iris_species &lt;-<span class="st"> </span>iris_df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(species) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pull</span>(species)

<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(iris_df)) {
  tmp_df &lt;-<span class="st"> </span>iris_df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">filter</span>(species <span class="op">==</span><span class="st"> </span>iris_species[i])
  species_name &lt;-<span class="st"> </span>iris_species[i]
  tmp_df <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">write_csv</span>(<span class="kw">paste0</span>(<span class="st">&quot;data/iris_&quot;</span>, species_name, <span class="st">&quot;.csv&quot;</span>))
}

<span class="kw">Sys.glob</span>(<span class="st">&quot;data/iris_*.csv&quot;</span>)</code></pre></div>
<pre><code>[1] &quot;data/iris_NA.csv&quot;         &quot;data/iris_setosa.csv&quot;    
[3] &quot;data/iris_versicolor.csv&quot; &quot;data/iris_virginica.csv&quot; </code></pre>
<p>로컬 파일 <code>iris_종명.csv</code> 형식으로 저장된 데이터를 함수형 프로그래밍을 통해 불러와서 분석작업을 수행해보자. <code>map()</code> 함수를 사용해서 각 종별로 데이터를 깔끔하게 불러왔다.</p>
<p><code>iris_filename</code> 벡터에 <code>iris_종명.csv</code>과 경로명이 포함된 문자열을 저장시켜 놓고 <code>read_csv()</code> 함수를 각 벡터 원소에 적용시켜 출력값으로 리스트 <code>iris_list</code> 객체를 생성시켰다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">iris_filename &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;data/iris_setosa.csv&quot;</span>, <span class="st">&quot;data/iris_versicolor.csv&quot;</span>, <span class="st">&quot;data/iris_virginica.csv&quot;</span>)

iris_list &lt;-<span class="st"> </span><span class="kw">map</span>(iris_filename, read_csv) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">set_names</span>(iris_species)

listviewer<span class="op">::</span><span class="kw">jsonedit</span>(iris_list)</code></pre></div>
<pre><code>Error in loadNamespace(name): there is no package called &#39;listviewer&#39;</code></pre>
<h2 id="functional-programming-purrr-analysis">데이터 분석사례</h2>
<p><code>iris_list</code> 각 원소는 데이터프레임이라 <code>summary</code> 함수를 사용해서 기술 통계량을 구할 수도 있다. 물론 <code>cor()</code> 함수를 사용해서 <code>iris_list</code>의 각 원소를 지정하는 <code>.x</code> 여기서는 종별 데이터프레임에서 변수 두개를 추출하여 <code>sepal_length</code>, <code>sepal_width</code> 이 둘간의 스피커만 상관계수를 계산하는데 출력값이 <code>double</code> 연속형이라 <code>map_dbl</code>로 저정하여 작업시킨다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map</span>(iris_list, summary)</code></pre></div>
<pre><code>$setosa
  sepal_length    sepal_width     petal_length    petal_width   
 Min.   :4.300   Min.   :2.300   Min.   :1.000   Min.   :0.100  
 1st Qu.:4.800   1st Qu.:3.125   1st Qu.:1.400   1st Qu.:0.200  
 Median :5.000   Median :3.400   Median :1.500   Median :0.200  
 Mean   :5.006   Mean   :3.418   Mean   :1.464   Mean   :0.244  
 3rd Qu.:5.200   3rd Qu.:3.675   3rd Qu.:1.575   3rd Qu.:0.300  
 Max.   :5.800   Max.   :4.400   Max.   :1.900   Max.   :0.600  
   species         
 Length:50         
 Class :character  
 Mode  :character  
                   
                   
                   

$versicolor
  sepal_length    sepal_width     petal_length   petal_width   
 Min.   :4.900   Min.   :2.000   Min.   :3.00   Min.   :1.000  
 1st Qu.:5.600   1st Qu.:2.525   1st Qu.:4.00   1st Qu.:1.200  
 Median :5.900   Median :2.800   Median :4.35   Median :1.300  
 Mean   :5.936   Mean   :2.770   Mean   :4.26   Mean   :1.326  
 3rd Qu.:6.300   3rd Qu.:3.000   3rd Qu.:4.60   3rd Qu.:1.500  
 Max.   :7.000   Max.   :3.400   Max.   :5.10   Max.   :1.800  
   species         
 Length:50         
 Class :character  
 Mode  :character  
                   
                   
                   

$virginica
  sepal_length    sepal_width     petal_length    petal_width   
 Min.   :4.900   Min.   :2.200   Min.   :4.500   Min.   :1.400  
 1st Qu.:6.225   1st Qu.:2.800   1st Qu.:5.100   1st Qu.:1.800  
 Median :6.500   Median :3.000   Median :5.550   Median :2.000  
 Mean   :6.588   Mean   :2.974   Mean   :5.552   Mean   :2.026  
 3rd Qu.:6.900   3rd Qu.:3.175   3rd Qu.:5.875   3rd Qu.:2.300  
 Max.   :7.900   Max.   :3.800   Max.   :6.900   Max.   :2.500  
   species         
 Length:50         
 Class :character  
 Mode  :character  
                   
                   
                   </code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(iris_list, <span class="op">~</span><span class="kw">cor</span>(.x<span class="op">$</span>sepal_length, .x<span class="op">$</span>sepal_width, <span class="dt">method =</span> <span class="st">&quot;spearman&quot;</span>))</code></pre></div>
<pre><code>    setosa versicolor  virginica 
 0.7686085  0.5176060  0.4265165 </code></pre>
<h2 id="functional-programming-purrr-random-number">난수생성 사례</h2>
<p>서로 다른 난수를 생성시키는 방법을 살펴보자. 정규분포를 가정하고 평균과 표준편차를 달리하는 모수를 지정하고 난수갯수도 숫자를 달리하여 난수를 생성시킨다.</p>
<h3 id="functional-programming-purrr-random-number-mean"><span class="math inline">\(\mu\)</span> 평균만 달리함</h3>
<p>정규분포에서 난수를 10개 추출하는데 표준편차는 1로 고정시키고, 평균만 달리한다. 평균만 달리하기 때문에 <code>map()</code> 함수를 그대로 사용한다. 즉, 입력값으로 평균만 달리하는 리스트를 입력값으로 넣는다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## 평균을 달리하는 경우
normal_mean &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">10</span>)

sim_mu_name &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;mu: &quot;</span>, normal_mean)

sim_mu_list &lt;-<span class="st"> </span><span class="kw">map</span>(normal_mean, <span class="op">~</span><span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">mean =</span> .x, 
                            <span class="dt">random_number =</span> <span class="kw">rnorm</span>(<span class="dt">mean=</span>.x, <span class="dt">sd=</span><span class="dv">1</span>, <span class="dt">n=</span><span class="dv">10</span>))) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">set_names</span>(sim_mu_name)

<span class="kw">map_dbl</span>(sim_mu_list, <span class="op">~</span><span class="kw">mean</span>(.x<span class="op">$</span>random_number))</code></pre></div>
<pre><code>     mu: 1      mu: 5     mu: 10 
 0.6175196  4.9073332 10.3894336 </code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">listviewer<span class="op">::</span><span class="kw">jsonedit</span>(sim_mu_list)</code></pre></div>
<pre><code>Error in loadNamespace(name): there is no package called &#39;listviewer&#39;</code></pre>
<h3 id="functional-programming-purrr-random-number-mean-sd"><span class="math inline">\(\mu\)</span> 평균과 <span class="math inline">\(\sigma\)</span> 표준편차를 달리함</h3>
<p>난수갯수만 고정시키고 평균과 표준편차를 달리하여 난수를 정규분포에서 추출한다. 입력값으로 평균과 표준편차 두개가 되기 때문에 <code>map2()</code> 함수를 사용한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## 평균과 표준편차를 달리하는 경우
normal_mean &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">10</span>)
normal_sd   &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">10</span>,<span class="dv">5</span>,<span class="dv">1</span>)

sim_mu_sd_name &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;mu: &quot;</span>, normal_mean, <span class="st">&quot;,  sd: &quot;</span>, normal_sd)

sim_mu_sd_list &lt;-<span class="st"> </span><span class="kw">map2</span>(normal_mean, normal_sd, 
                        <span class="op">~</span><span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">mean =</span> .x, <span class="dt">sd =</span> .y,
                            <span class="dt">random_number =</span> <span class="kw">rnorm</span>(<span class="dt">mean=</span>.x, <span class="dt">sd=</span>.y, <span class="dt">n=</span><span class="dv">10</span>))) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">set_names</span>(sim_mu_sd_name)

<span class="kw">map_dbl</span>(sim_mu_sd_list, <span class="op">~</span><span class="kw">sd</span>(.x<span class="op">$</span>random_number))</code></pre></div>
<pre><code>mu: 1,  sd: 10  mu: 5,  sd: 5 mu: 10,  sd: 1 
     5.0812271      4.5497786      0.8242514 </code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">listviewer<span class="op">::</span><span class="kw">jsonedit</span>(sim_mu_sd_list)</code></pre></div>
<pre><code>Error in loadNamespace(name): there is no package called &#39;listviewer&#39;</code></pre>
<h3 id="functional-programming-purrr-random-number-mean-sd-size"><span class="math inline">\(\mu\)</span> 평균, <span class="math inline">\(\sigma\)</span> 표준편차, 표본크기를 달리함</h3>
<p><span class="math inline">\(\mu\)</span> 평균, <span class="math inline">\(\sigma\)</span> 표준편차, 표본크기를 모두 다르게 지정하여 난수를 추출한다. 이런 경우 <code>pmap()</code> 함수를 사용하고 입력 리스트가 다수라 이를 <code>normal_list</code>로 한번더 감싸서 이름이 붙은 리스트(named list)형태로 넣어주고, 이를 <code>function()</code> 함수의 내부 인수로 사용한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## 평균, 표준편차, 표본크기를 달리하는 경우
normal_mean &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">10</span>)
normal_sd   &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">10</span>,<span class="dv">5</span>,<span class="dv">1</span>)
normal_size &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>)

sim_mu_sd_size_name &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;mu: &quot;</span>, normal_mean, <span class="st">&quot;,  sd: &quot;</span>, normal_sd,
                              <span class="st">&quot;  size: &quot;</span>, normal_size)

normal_list &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">normal_mean=</span>normal_mean, <span class="dt">normal_sd=</span>normal_sd, <span class="dt">normal_size=</span>normal_size)

sim_mu_sd_size_list &lt;-<span class="st"> </span><span class="kw">pmap</span>(normal_list,
                            <span class="cf">function</span>(normal_mean, normal_sd, normal_size)
                        <span class="kw">data.frame</span>(<span class="dt">mean=</span>normal_mean, <span class="dt">sd =</span> normal_sd, <span class="dt">size =</span> normal_size,
                            <span class="dt">random_number =</span> <span class="kw">rnorm</span>(<span class="dt">mean=</span>normal_mean, <span class="dt">sd=</span>normal_sd, <span class="dt">n=</span>normal_size))) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">set_names</span>(sim_mu_sd_size_name)

<span class="kw">map_dbl</span>(sim_mu_sd_size_list, <span class="op">~</span><span class="kw">length</span>(.x<span class="op">$</span>random_number))</code></pre></div>
<pre><code>mu: 1,  sd: 10  size: 10  mu: 5,  sd: 5  size: 20 mu: 10,  sd: 1  size: 30 
                      10                       20                       30 </code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">listviewer<span class="op">::</span><span class="kw">jsonedit</span>(sim_mu_sd_size_list)</code></pre></div>
<pre><code>Error in loadNamespace(name): there is no package called &#39;listviewer&#39;</code></pre>
<h2 id="functional-programming-purrr-ggplot"><code>ggplot</code> 시각화 <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></h2>
<p><code>list-column</code>을 활용하여 티블(tibble) 데이터프레임에 담아서 시각화를 진행해도 되고, 다른 방법으로 리스트에 담아서 이를 한장에 찍는 것도 가능하다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(gapminder)

## 데이터 -----
three_country &lt;-<span class="st">  </span><span class="kw">c</span>(<span class="st">&quot;Korea, Rep.&quot;</span>, <span class="st">&quot;Japan&quot;</span>, <span class="st">&quot;China&quot;</span>)

gapminder_tbl &lt;-<span class="st"> </span>gapminder <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(<span class="kw">str_detect</span>(continent, <span class="st">&quot;Asia&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(continent, country) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">nest</span>() <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>continent) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(country <span class="op">%in%</span><span class="st"> </span>three_country )

## 티블 데이터 시각화 -----
gapminder_plot_tbl &lt;-<span class="st"> </span>gapminder_tbl <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">graph =</span> <span class="kw">map2</span>(data, three_country, 
                     <span class="op">~</span><span class="kw">ggplot</span>(.x, <span class="kw">aes</span>(<span class="dt">x=</span>year, <span class="dt">y=</span>gdpPercap)) <span class="op">+</span>
<span class="st">                       </span><span class="kw">geom_line</span>() <span class="op">+</span>
<span class="st">                       </span><span class="kw">labs</span>(<span class="dt">title=</span>.y)))

gapminder_plot_tbl</code></pre></div>
<pre><code># A tibble: 3 x 3
  country     data              graph   
  &lt;fct&gt;       &lt;list&gt;            &lt;list&gt;  
1 China       &lt;tibble [12 × 4]&gt; &lt;S3: gg&gt;
2 Japan       &lt;tibble [12 × 4]&gt; &lt;S3: gg&gt;
3 Korea, Rep. &lt;tibble [12 × 4]&gt; &lt;S3: gg&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## 리스트 데이터 시각화 -----
gapminder_plot &lt;-<span class="st"> </span><span class="kw">map2</span>(gapminder_tbl<span class="op">$</span>data , three_country, 
                     <span class="op">~</span><span class="kw">ggplot</span>(.x, <span class="kw">aes</span>(<span class="dt">x=</span>year, <span class="dt">y=</span>gdpPercap)) <span class="op">+</span>
<span class="st">                       </span><span class="kw">geom_line</span>() <span class="op">+</span>
<span class="st">                       </span><span class="kw">labs</span>(<span class="dt">title=</span>.y))

<span class="kw">walk</span>(gapminder_plot, print)</code></pre></div>
<p><img src="figure/fp-iris-viz-1.png" title="plot of chunk fp-iris-viz" alt="plot of chunk fp-iris-viz" style="display: block; margin: auto;" /><img src="figure/fp-iris-viz-2.png" title="plot of chunk fp-iris-viz" alt="plot of chunk fp-iris-viz" style="display: block; margin: auto;" /><img src="figure/fp-iris-viz-3.png" title="plot of chunk fp-iris-viz" alt="plot of chunk fp-iris-viz" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## 리스트 데이터 시각화 - 한장에 찍기 -----
cowplot<span class="op">::</span><span class="kw">plot_grid</span>(<span class="dt">plotlist =</span> gapminder_plot)</code></pre></div>
<p><img src="figure/fp-iris-viz-4.png" title="plot of chunk fp-iris-viz" alt="plot of chunk fp-iris-viz" style="display: block; margin: auto;" /></p>
<h1 id="fp-theory-practice">함수형 프로그래밍 이론과 실제</h1>
<p>함수는 다음과 같이 될 수도 있어 함수형 프로그래밍 언어가 된다. <a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<ul>
<li>함수의 인자</li>
<li>함수로 반환</li>
<li>리스트에 저장</li>
<li>변수에 저장</li>
<li>무명함수</li>
<li>조작할 수 있다.</li>
</ul>
<p>Firstly, functional languages have first-class functions, functions that behave like any other data structure. In R, this means that you can do anything with a function that you can do with a vector: you can assign them to variables, store them in lists, pass them as arguments to other functions, create them inside functions, and even return them as the result of a function.</p>
<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 10px;}
</style>
<div class="blue">
<p>John Chambers 창시자가 말하는 R 계산의 기본원칙</p>
<ul>
<li>존재하는 모든 것은 객체다. (Everything that exists is an object.)</li>
<li>일어나는 모든 것은 함수호출이다. (Everything that happens is a function call.)</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)
<span class="kw">class</span>(<span class="st">`</span><span class="dt">%&gt;%</span><span class="st">`</span>)</code></pre></div>
<pre><code>[1] &quot;function&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="st">`</span><span class="dt">$</span><span class="st">`</span>)</code></pre></div>
<pre><code>[1] &quot;function&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="st">`</span><span class="dt">&lt;-</span><span class="st">`</span>)</code></pre></div>
<pre><code>[1] &quot;function&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="st">`</span><span class="dt">+</span><span class="st">`</span>)</code></pre></div>
<pre><code>[1] &quot;function&quot;</code></pre>
</div>
<h2 id="pure-vs-impure-function">순수한 함수 vs 순수하지 않은 함수</h2>
<p><strong>순수한 함수(pure function)</strong>는 입력값에만 출력값이 의존하게 되는 특성과 부수효과(side-effect)를 갖지 않는 반면 <strong>순수하지 않은 함수(impure function)</strong>는 환경에 의존하며 부수효과도 갖는다.</p>
<div class="row">
<div class="col-md-6">
<p><strong>순수한 함수(pure function)</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">min</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">100</span>)</code></pre></div>
<pre><code>[1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">100</span>)</code></pre></div>
<pre><code>[1] 50.5</code></pre>
</div>
<div class="col-md-6">
<p><strong>순수하지 않은 함수(impure function)</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Sys.time</span>()</code></pre></div>
<pre><code>[1] &quot;2019-01-02 17:53:43 KST&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rnorm</span>(<span class="dv">10</span>)</code></pre></div>
<pre><code> [1]  1.878177241 -0.177908465  0.909990989 -0.985579732 -0.781199917
 [6] -0.715173480 -0.004786622 -0.369596794  0.422803321 -2.216696651</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># write_csv(&quot;data/sample.csv&quot;)</span></code></pre></div>
</div>
</div>
<h2 id="fp-lambda-functin">무명함수(lambda function)와 매퍼(mapper)</h2>
<p><span class="math inline">\(\lambda\)</span> (람다) 함수는 무명(anonymous) 함수는 함수명을 갖는 일반적인 함수와 비교하여 함수의 좋은 점은 그대로 누리면서 함수가 많아 함수명으로 메모리가 난잡하게 지져분해지는 것을 막을 수 있다.</p>
<p>무명함수로 기능르 구현한 후에 매퍼(mapper)를 사용해서 <code>as_mapper()</code> 명칭을 부여하여 함수처럼 사용하는 것도 가능하다. 매퍼(mapper)를 사용하는 이유를 다음과 같이 정리할 수 있다.</p>
<ul>
<li>간결함(Concise)</li>
<li>가독성(Easy to read)</li>
<li>재사용성(Reusable)</li>
</ul>
<p>정치인 페이스북 페이지에서 팬수를 추출한다. 그리고 이를 이름이 부은 리스트(named list)로 일자별 팬수 추이를 리스트로 준비한다. 그리고 나서 안철수, 문재인, 심상정 세 후보에 대한 최고 팬수증가를 무명함수로 계산한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)
## 데이터프레임을 리스트로 변환
ahn_df  &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;data/fb_ahn.csv&quot;</span>)  <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rename</span>(<span class="dt">fans =</span> ahn_fans) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">fans_lag =</span> <span class="kw">lag</span>(fans),
         <span class="dt">fans_diff =</span> fans <span class="op">-</span><span class="st"> </span>fans_lag) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(fdate, <span class="dt">fans =</span> fans_diff) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(fans))
moon_df &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;data/fb_moon.csv&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rename</span>(<span class="dt">fans =</span> moon_fans) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">fans_lag =</span> <span class="kw">lag</span>(fans),
         <span class="dt">fans_diff =</span> fans <span class="op">-</span><span class="st"> </span>fans_lag) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(fdate, <span class="dt">fans =</span> fans_diff) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(fans))
sim_df  &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;data/fb_sim.csv&quot;</span>)  <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rename</span>(<span class="dt">fans =</span> sim_fans) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">fans_lag =</span> <span class="kw">lag</span>(fans),
         <span class="dt">fans_diff =</span> fans <span class="op">-</span><span class="st"> </span>fans_lag) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(fdate, <span class="dt">fans =</span> fans_diff) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(fans))

convert_to_list &lt;-<span class="st"> </span><span class="cf">function</span>(df) {
  df_fans_v &lt;-<span class="st"> </span>df<span class="op">$</span>fans <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">set_names</span>(df<span class="op">$</span>fdate)
  <span class="kw">return</span>(df_fans_v)
}

ahn_v  &lt;-<span class="st"> </span><span class="kw">convert_to_list</span>(ahn_df)
moon_v &lt;-<span class="st"> </span><span class="kw">convert_to_list</span>(moon_df)
sim_v  &lt;-<span class="st"> </span><span class="kw">convert_to_list</span>(sim_df)

fans_lst &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">ahn_fans  =</span> ahn_v,
                 <span class="dt">moon_fans =</span> moon_v,
                 <span class="dt">sim_fans  =</span> sim_v)

listviewer<span class="op">::</span><span class="kw">jsonedit</span>(fans_lst)</code></pre></div>
<pre><code>Error in loadNamespace(name): there is no package called &#39;listviewer&#39;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## 무명함수 테스트
<span class="kw">map_dbl</span>(fans_lst, <span class="op">~</span><span class="kw">max</span>(.x))</code></pre></div>
<pre><code> ahn_fans moon_fans  sim_fans 
      796      1464      2029 </code></pre>
<p><code>rlang_lambda_function</code> 무명함수로 <code>increase_1000_fans</code> 작성해서 일별 팬수 증가가 1000명 이상인 경우 <code>keep()</code> 함수를 사용해서 각 후보별로 추출할 수 있다. <code>discard()</code> 함수를 사용해서 반대로 버려버릴 수도 있다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">increase_1000_fans &lt;-<span class="st"> </span><span class="kw">as_mapper</span>( <span class="op">~</span>.x <span class="op">&gt;</span><span class="st"> </span><span class="dv">1000</span>)

<span class="kw">map</span>(fans_lst, <span class="op">~</span><span class="kw">keep</span>(.x, increase_1000_fans))</code></pre></div>
<pre><code>$ahn_fans
named numeric(0)

$moon_fans
2017-03-28 2017-04-18 2017-04-20 
      1464       1310       1093 

$sim_fans
2017-03-12 2017-03-13 2017-04-14 2017-04-19 2017-04-20 2017-04-21 
      1301       1079       1070       1441       1190       1025 
2017-04-24 2017-04-25 
      1948       2029 </code></pre>
<p><a href="https://terms.naver.com/entry.nhn?docId=1116302&amp;cid=40942&amp;categoryId=31530">술어논리(predicate logic)</a>은 조건을 테스트하여 참(<code>TRUE</code>), 거짓(<code>FALSE</code>)을 반환시킨다. <code>every</code>, <code>some</code>을 사용하여 팬수가 증가한 날이 매일 1,000명이 증가했는지, 전부는 아니고 일부 특정한 날에 1,000명이 증가했는지 파악할 수 있다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## 세후보 팬수가 매일 모두 1000명 이상 증가했나요?
<span class="kw">map</span>(fans_lst, <span class="op">~</span><span class="kw">every</span>(.x, increase_1000_fans))</code></pre></div>
<pre><code>$ahn_fans
[1] FALSE

$moon_fans
[1] FALSE

$sim_fans
[1] FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## 세후보 팬수가 전체는 아니고 일부 특정한 날에 1000명 이상 증가했나요?
<span class="kw">map</span>(fans_lst, <span class="op">~</span><span class="kw">some</span>(.x, increase_1000_fans))</code></pre></div>
<pre><code>$ahn_fans
[1] FALSE

$moon_fans
[1] TRUE

$sim_fans
[1] TRUE</code></pre>
<h2 id="high-order-function">고차 함수(High order function)</h2>
<p>고차 함수(High order function)는 함수의 인자로 함수를 받아 함수로 반환시키는 함수를 지칭한다. <code>high_order_fun</code> 함수는 함수를 인자(<code>func</code>)로 받아 함수를 반환시키는 고차함수다. 평균 함수(<code>mean</code>)를 인자로 넣어 출력값으로 <code>mean_na()</code> 함수를 새롭게 생성시킨다. <code>NA</code>가 포함된 벡터를 넣어 평균값을 계산하게 된다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">high_order_fun &lt;-<span class="st"> </span><span class="cf">function</span>(func){
  <span class="cf">function</span>(...){
    <span class="kw">func</span>(..., <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
  }
}

mean_na &lt;-<span class="st"> </span><span class="kw">high_order_fun</span>(mean)
<span class="kw">mean_na</span>( <span class="kw">c</span>(<span class="ot">NA</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>) )</code></pre></div>
<pre><code>[1] 5.5</code></pre>
<p>벡터가 입력값으로 들어가서 벡터가 출력값으로 나오는 보통 함수(Regular Function)외에 고차함수는 3가지 유형이 있다.</p>
<ul>
<li>벡터 → 함수: 함수공장(Function Factory)</li>
<li>함수 → 벡터: Functional - <code>for</code>루프를 <code>purrr</code> 팩키지 <code>map()</code> 함수로 대체</li>
<li>함수 → 함수: 함수연산자(Function Operator) - <code>Functional</code>과 함께 사용될 경우 <code>adverbs</code>로서 강력한 기능을 발휘</li>
</ul>
<p><img src="fig/fp.png" alt="고차함수 유형" width="57%" /></p>
<h2 id="adverbs-safely-possibly">부사(<code>adverbs</code>) - <code>safely</code>, <code>possibly</code>,…</h2>
<p><code>purrr</code> 팩키지의 대표적인 부사(adverbs)에는 <code>possibly()</code>와 <code>safely()</code>가 있다. 그외에도 <code>silently()</code>, <code>surely()</code> 등 다른 부사도 있으니 필요한 경우 <code>purrr</code> 팩키지 문서를 참조한다.</p>
<p><code>safely(mean)</code>은 동사 함수(<code>mean()</code>)를 받아 부사 <code>safely()</code>로 “부사 + 동사”로 기능이 추가된 부사 동사를 반환시킨다. 따라서, <code>NA</code>가 추가된 벡터를 넣을 경우 <code>$result</code>와 <code>$error</code>를 원소로 갖는 리스트를 반환시킨다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mean_safe &lt;-<span class="st"> </span><span class="kw">safely</span>(mean)
<span class="kw">class</span>(mean_safe)</code></pre></div>
<pre><code>[1] &quot;function&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean_safe</span>(<span class="kw">c</span>(<span class="ot">NA</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>))</code></pre></div>
<pre><code>$result
[1] NA

$error
NULL</code></pre>
<p>이를 활용하여 오류처리작업을 간결하게 수행시킬 수 있다. <code>$result</code>와 <code>$error</code>을 원소로 갖는 리스트를 반환시키기 때문에 오류와 결과값을 추출하여 후속작업을 수행하여 디버깅하는데 유용하게 활용할 수 있다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test_lst &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;NA&quot;</span>, <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>)
log_safe &lt;-<span class="st"> </span><span class="kw">safely</span>(log)

<span class="kw">map</span>(test_lst, log_safe) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map</span>(<span class="st">&quot;result&quot;</span>)</code></pre></div>
<pre><code>[[1]]
NULL

[[2]]
[1] 0

[[3]]
[1] 0.6931472

[[4]]
[1] 1.098612

[[5]]
[1] 1.386294

[[6]]
[1] 1.609438</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map</span>(test_lst, log_safe) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map</span>(<span class="st">&quot;error&quot;</span>)</code></pre></div>
<pre><code>[[1]]
&lt;simpleError in log(x = x, base = base): 수학함수에 숫자가 아닌 인자가 전달되었습니다&gt;

[[2]]
NULL

[[3]]
NULL

[[4]]
NULL

[[5]]
NULL

[[6]]
NULL</code></pre>
<p>반면에 <code>possibly()</code>는 결과와 <code>otherwise</code> 값을 반환시켜서 오류가 발생되면 중단되는 것이 아니라 오류가 있다는 사실을 알고 예외처리시킨 후에 쭉 정상진행시킨다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">max_possibly &lt;-<span class="st"> </span><span class="kw">possibly</span>(sum, <span class="dt">otherwise =</span> <span class="st">&quot;watch out&quot;</span>)

<span class="kw">max_possibly</span>(<span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>))</code></pre></div>
<pre><code>[1] 55</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">max_possibly</span>(<span class="kw">c</span>(<span class="ot">NA</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>))</code></pre></div>
<pre><code>[1] NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">max_possibly</span>(<span class="kw">c</span>(<span class="st">&quot;NA&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>))</code></pre></div>
<pre><code>[1] &quot;watch out&quot;</code></pre>
<p><code>possibly()</code>는 부울 논리값, <code>NA</code>, 문자열, 숫자를 반환시킬 수 있다.</p>
<p><code>transpose()</code>와 결합하여 <code>safely()</code>, <code>possibly()</code> 결과를 변형시킬 수도 있다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map</span>(test_lst, log_safe) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">length</span>()</code></pre></div>
<pre><code>[1] 6</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map</span>(test_lst, log_safe) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">transpose</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">length</span>()</code></pre></div>
<pre><code>[1] 2</code></pre>
<p><code>compact()</code>를 사용해서 <code>NULL</code>을 제거하는데, 앞서 <code>possibly()</code>의 인자로 <code>otherwise=</code>를 지정하는 경우 <code>otherwise=NULL</code>와 같이 정의해서 예외처리로 <code>NULL</code>을 만들어 내고 <code>compact()</code>로 정상처리된 데이터만 얻는 작업흐름을 갖춘다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">null_lst &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>, <span class="ot">NULL</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="ot">NULL</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="ot">NA</span>)
<span class="kw">compact</span>(null_lst)</code></pre></div>
<pre><code>[[1]]
[1] 1

[[2]]
[1] 3

[[3]]
[1] 4

[[4]]
[1] 6

[[5]]
[1] 7

[[6]]
[1] NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">possibly_log &lt;-<span class="st"> </span><span class="kw">possibly</span>(log, <span class="dt">otherwise =</span> <span class="ot">NULL</span>)
<span class="kw">map</span>(null_lst, possibly_log) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">compact</span>()</code></pre></div>
<pre><code>[[1]]
[1] 0

[[2]]
[1] 1.098612

[[3]]
[1] 1.386294

[[4]]
[1] 1.791759

[[5]]
[1] 1.94591

[[6]]
[1] NA</code></pre>
<h1 id="fp-clean-code">깨끗한 코드(clean code) <a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></h1>
<p><code>round_mean()</code> 함수를 <code>compose()</code> 함수를 사용해서 <code>mean()</code> 함수로 평균을 구한 후에 <code>round()</code>함수로 반올림하는 코드를 다음과 같이 쉽게 작성할 수 있다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">round_mean &lt;-<span class="st"> </span><span class="kw">compose</span>(round, mean)
<span class="kw">round_mean</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)</code></pre></div>
<pre><code>[1] 6</code></pre>
<p>두번째 사례로 전형적인 데이터 분석 사례로 <code>lm()</code> → <code>anova()</code> → <code>tidy()</code>를 통해 한방에 선형회귀 모형 산출물을 깨끗한 코드로 작성하는 사례를 살펴보자.</p>
<p><code>mtcars</code> 데이터셋에서 연비 예측에 변수 두개를 넣고 일반적인 <code>lm()</code> 선형예측모형 제작방식과 동일하게 인자를 넣는다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">clean_lm &lt;-<span class="st"> </span><span class="kw">compose</span>(broom<span class="op">::</span>tidy, anova, lm)
<span class="kw">clean_lm</span>(mpg <span class="op">~</span><span class="st"> </span>hp <span class="op">+</span><span class="st"> </span>wt, <span class="dt">data=</span>mtcars)</code></pre></div>
<pre><code># A tibble: 3 x 6
  term         df sumsq meansq statistic   p.value
  &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
1 hp            1  678. 678.       101.   5.99e-11
2 wt            1  253. 253.        37.6  1.12e- 6
3 Residuals    29  195.   6.73      NA   NA       </code></pre>
<p><code>compose()</code>를 통해 함수를 조합하는 경우 함수의 인자를 함께 전달해야될 경우가 있다. 이와 같은 경우 <code>partial()</code>을 사용해서 인자를 넘기는 함수를 제작하여 <code>compose()</code>에 넣어준다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">robust_round_mean &lt;-<span class="st"> </span><span class="kw">compose</span>(
  <span class="kw">partial</span>(round, <span class="dt">digits=</span><span class="dv">1</span>),
  <span class="kw">partial</span>(mean, <span class="dt">na.rm=</span><span class="ot">TRUE</span>))
<span class="kw">robust_round_mean</span>(<span class="kw">c</span>(<span class="ot">NA</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>))</code></pre></div>
<pre><code>[1] 5.5</code></pre>
<p>리스트 칼럼(list-column)과 결합하여 모형에서 나온 데이터 분석결과를 깔끔하게 코드로 제작해보자. 먼저 <code>lm</code>을 돌려 모형 요약하는 함수 <code>summary</code>를 통해 <code>r.squared</code>값을 추출하는 함수를 <code>summary_lm</code>으로 제작한다.</p>
<p>그리고 나서 <code>nest()</code> 함수로 리스트 칼럼(list-column)을 만들고 두개의 집단 수동/자동을 나타내는 <code>am</code> 변수를 그룹으로 삼아 두 집단에 속한 수동/자동 데이터에 대한 선형 회귀모형을 적합시키고 나서 “r.squared”값을 추출하여 이를 티블 데이터프레임에 저장시킨다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">summary_lm &lt;-<span class="st"> </span><span class="kw">compose</span>(summary, lm) 

mtcars <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">group_by</span>(am) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">nest</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">lm_mod =</span> <span class="kw">map</span>(data, <span class="op">~</span><span class="st"> </span><span class="kw">summary_lm</span>(mpg <span class="op">~</span><span class="st"> </span>hp <span class="op">+</span><span class="st"> </span>wt, <span class="dt">data =</span> .x)),
         <span class="dt">r_squared =</span> <span class="kw">map</span>(lm_mod, <span class="st">&quot;r.squared&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">unnest</span>(r_squared)</code></pre></div>
<pre><code># A tibble: 2 x 4
     am data               lm_mod           r_squared
  &lt;dbl&gt; &lt;list&gt;             &lt;list&gt;               &lt;dbl&gt;
1     1 &lt;tibble [13 × 10]&gt; &lt;S3: summary.lm&gt;     0.837
2     0 &lt;tibble [19 × 10]&gt; &lt;S3: summary.lm&gt;     0.768</code></pre>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://www.brodrigues.co/fput/">Bruno Rodrigues(2016), “Functional programming and unit testing for data munging with R”, LeanPub, 2016-12-23</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="https://jennybc.github.io/purrr-tutorial/index.html"><code>purrr</code> tutorial: Lessons and Examples</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="https://github.com/jennybc/purrr-tutorial/"><code>purrr</code> tutorial GitHub Webpage</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="https://aosmith.rbind.io/2018/08/20/automating-exploratory-plots/">Very statisticious (August 20, 2018), “Automating exploratory plots with ggplot2 and purrr”</a><a href="#fnref4">↩</a></p></li>
<li id="fn5"><p><a href="https://adv-r.hadley.nz/fp.html">Advanced R, “Introduction”</a><a href="#fnref5">↩</a></p></li>
<li id="fn6"><p><a href="https://colinfay.me/purrr-code-optim/">Colin Fay, “A Crazy Little Thing Called {purrr} - Part 5: code optimization”</a><a href="#fnref6">↩</a></p></li>
</ol>
</div>
        </div>
      </div>
      </article>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="https://github.com/swcarpentry/lesson-template">Source</a>
        <a class="label swc-blue-bg" href="mailto:admin@software-carpentry.org">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    
      ga('create', 'UA-37305346-2', 'auto');
      ga('send', 'pageview');
    
    </script>
  </body>
</html>
