<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: 데이터 과학</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="Software Carpentry Blog" href="http://software-carpentry.org/feed.xml"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    
      ga('create', 'UA-59802572-19', 'auto');
      ga('send', 'pageview');
    
    </script>
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="http://software-carpentry.org" title="Software Carpentry">
          <img alt="Software Carpentry banner" src="img/software-carpentry-banner.png" />
        </a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <a href="index.html"><h1 class="title">데이터 과학</h1></a>
          <h2 class="subtitle">함수형 프로그래밍(Functional Programming)</h2>
          <section class="objectives panel panel-warning">
<div class="panel-heading">
<h2 id="학습-목표"><span class="glyphicon glyphicon-certificate"></span>학습 목표</h2>
</div>
<div class="panel-body">
<ul>
<li>데이터 과학 맥락에서 함수형 프로그래밍을 이해한다.</li>
<li>함수형 프로그래밍과 짝꿍인 단위 테스트에 대해서 살펴본다.</li>
<li>함수형 프로그래밍을 수치해석 예제를 통해 학습한다.</li>
</ul>
</div>
</section>
<h2 id="r-functional-programming">1. 함수형 프로그래밍</h2>
<p>함수형 프로그래밍은 코드를 작성하는 한 방식으로 특정 연산을 수행하는 함수를 먼저 작성하고 나서, 사용자로 함수를 호출해서 작업을 수행하는 방식이다.</p>
<p>순수 함수형 언어, 예를 들어 <a href="https://ko.wikipedia.org/wiki/하스켈">하스케(Haskell)</a>은 루프가 없다. 루푸없이 어떻게 프로그램을 작성할 수 있을까? 루프는 재귀(recursion)로 대체된다. 이런 이유로 아래에서 뉴톤 방법을 통해 근을 구하는 방식을 R코드로 두가지 방법을 보여준다. R은 아직 <a href="http://hanmomhanda.github.io/2015/07/27/%EC%9E%AC%EA%B7%80-%EB%B0%98%EB%B3%B5-Tail-Recursion/">꼬리 호출(tail-call recurssion)</a> 기능을 제공하지 않기 때문에 루프를 사용하는 것이 더 낫다.</p>
<p>수학 함수는 멋진 특성이 있는데, 즉 해당 입력에 항상 동일한 결과를 갖는다. 이 특성을 <strong>참조 투명성(referential transparaency)</strong> 이라고 부른다. 참조 투명성은 <strong>부수효과(side effect)</strong> 없음을 표현하는 속성인데, 함수가 결과값 외에 다른 상태를 변경시킬 때 부수효과(side effect)가 있다고 한다. 부수 효과는 프로그램 버그를 발생시키는 온상으로, 부수 효과를 없애면 디버깅이 용이해진다. 따라서, 부수 효과를 제거하고 참조 투명성을 유지함으로써 데이터 분석 수행 결과를 예측 가능한 상태로 유지시켜 재현가능한 과학이 가능하게 된다.</p>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h3 id="함수형-프로그래밍"><span class="glyphicon glyphicon-pushpin"></span>함수형 프로그래밍</h3>
</div>
<div class="panel-body">
<p>R 함수형 프로그래밍을 이해하기 위해서는 먼저 자료구조에 대한 이해가 선행되어야 한다. 그리고 나서, 함수를 작성하는 이유와 더불어 작성법에 대한 이해도 확고히 해야만 한다.</p>
<p>객체(object)가 함수를 갖는 데이터라면, 클러져는 데이터를 갖는 함수다.</p>
<blockquote>
<p>“An object is data with functions. A closure is a function with data.” – John D. Cook</p>
</blockquote>
</div>
</aside>
<p>명령형 언어(Imperative Language) 방식으로 R코드를 쭉 작성하게 되면, 각 단계별로 상태가 변경되는 것에 대해 신경을 쓰고 관리를 해나가야 된다. 그렇지 않으면 예기치 않은 부수 효과가 발생하여 데이터 분석 및 모형을 잘못 해석하게 된다.</p>
<p>그렇다고, 부수효과가 없는 순수 함수가 반듯이 좋은 것은 아니다. 예를 들어 <code>rnorm()</code> 함수를 통해 평균 0, 분산 1인 난수를 생성시키는데, 항상 동일한 값만 뽑아내면 사용자에게 의미있는 함수는 아니다.</p>
<p>결국, 함수형 프로그래밍을 통해 <strong>테스팅(testing)</strong>과 <strong>디버깅(debugging)</strong>을 수월하게 하는 것이 추구하는 바이다. 이를 위해 다음 3가지 요인이 중요하다.</p>
<ul>
<li>한번에 한가지 작업을 수행하는 함수</li>
<li>부수효과(side effect) 회피</li>
<li>참조 투명성(Referential transparaency)</li>
</ul>
<h3 id="why-functional-programming">1.1. 왜 함수형 프로그래밍인가?</h3>
<p>데이터 분석을 아주 추상화해서 간략하게 얘기한다면 데이터프레임을 함수에 넣어 새로운 데이터프레임으로 만들어 내는 것이다.</p>
<p><img src="fig/fp-data-analysis.png" alt="데이터 분석 추상화" width="77%" /></p>
<p>데이터 분석, 데이터 전처리, 변수 선택, 모형 개발이 한번에 해결되는 것이 아니라서, 데이터프레임을 함수에 넣어 상태가 변경된 데이터프레임이 생성되고, 이를 다시 함수에 넣어 또다른 변경된 상태 데이터프레임을 얻게 되는 과정을 쭉 반복해 나간다.</p>
<p><img src="fig/fp-data-analysis-workflow.png" alt="데이터 분석 작업흐름" width="57%" /></p>
<p>따라서… 데이터 분석에는 함수형 프로그래밍 패러다임을 활용하고, 툴/패키지 개발에는 객체지향 프로그래밍 패러다임 사용이 권장된다.</p>
<p><img src="fig/fp-data-analysis-choice.png" alt="데이터 분석에는 함수형 프로그래밍" width="77%" /></p>
<h3 id="functional-programming-newton">1.2. <a href="https://en.wikipedia.org/wiki/Newton%27s_method">뉴튼 방법(Newton’s Method)</a></h3>
<p>뉴튼-랩슨 알고리즘으로도 알려진 뉴튼(Newton Method) 방법은 컴퓨터를 사용해서 수치해석 방법으로 실함수의 근을 찾아내는 방법이다.</p>
<p>특정 함수 <span class="math inline">\(f\)</span> 의 근을 찾을 경우, 함수 미분값 <span class="math inline">\(f&#39;\)</span>, 초기값 <span class="math inline">\(x_0\)</span>가 주어지면 근사적 근에 가까운 값은 다음과 같이 정의된다.</p>
<p><span class="math display">\[x_{1} = x_0 - \frac{f(x_0)}{f&#39;(x_0)}\]</span></p>
<p>이 과정을 반복하게 되면 오차가 매우 적게 근의 값에 도달하게 된다.</p>
<p><span class="math display">\[x_{n+1} = x_n - \frac{f(x_n)}{f&#39;(x_n)}\]</span></p>
<p>기하적으로 보면, 파란 선은 함수 <span class="math inline">\(f\)</span> 이고, <span class="math inline">\(f\)</span>를 미분한 <span class="math inline">\(f&#39;\)</span> 빨간 선은 뉴턴방법을 활용하여 근을 구해가는 과정을 시각적으로 보여주고 있다. <span class="math inline">\(x_{n-1}\)</span> 보다 <span class="math inline">\(x_n\)</span>이, <span class="math inline">\(x_n\)</span> 보다 <span class="math inline">\(x_{n+1}\)</span>이 함수 <span class="math inline">\(f\)</span> 근에 더 가깝게 접근해 나가는 것이 확인된다.</p>
<p><img src="fig/newton_method_ani.gif" alt="뉴튼 방법" width="57%" /></p>
<h3 id="functional-programming-newton-method">1.3. 뉴튼 방법 R 코드 <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></h3>
<p>뉴튼 방법을 R코들 구현하면 다음과 같이 612의 제곱근 값을 수치적으로 컴퓨터를 활용하여 구할 수 있다. <code>while</code>같은 루프를 활용하여 반복적으로 해를 구하는 것도 가능하지만 재귀를 활용하여 해를 구하는 방법이 코드를 작성하고 읽는 개발자 관점에서는 훨씬 더 편리하고 권장된다.</p>
<p>하지만, 속도는 <code>while</code> 루프를 사용하는 것이 R에서는 득이 많다. 이유는 오랜 세월에 걸쳐 최적화 과정을 거쳐 진화했기 때문이다.</p>
<div class="row">
<div class="col-md-6">
<p><strong>while 루프를 사용한 방법</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">find_root &lt;-<span class="st"> </span>function(guess, init, <span class="dt">eps =</span> <span class="dv">10</span>^(-<span class="dv">10</span>)){
    while(<span class="kw">abs</span>(init**<span class="dv">2</span> -<span class="st"> </span>guess) &gt;<span class="st"> </span>eps){
        init &lt;-<span class="st"> </span><span class="dv">1</span>/<span class="dv">2</span> *(init +<span class="st"> </span>guess/init)
        <span class="kw">cat</span>(<span class="st">&quot;현재 값: &quot;</span>, init, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    }
    <span class="kw">return</span>(init)
}

<span class="kw">find_root</span>(<span class="dv">612</span>, <span class="dv">10</span>)</code></pre></div>
<pre class="output"><code>현재 값:  35.6 
현재 값:  26.39551 
현재 값:  24.79064 
현재 값:  24.73869 
현재 값:  24.73863 
현재 값:  24.73863 
</code></pre>
<pre class="output"><code>[1] 24.73863
</code></pre>
</div>
<div class="col-md-6">
<p><strong>재귀를 사용한 방법</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">find_root_recur &lt;-<span class="st"> </span>function(guess, init, <span class="dt">eps =</span> <span class="dv">10</span>^(-<span class="dv">10</span>)){
    if(<span class="kw">abs</span>(init**<span class="dv">2</span> -<span class="st"> </span>guess) &lt;<span class="st"> </span>eps){
        <span class="kw">return</span>(init)
    } else{
        init &lt;-<span class="st"> </span><span class="dv">1</span>/<span class="dv">2</span> *(init +<span class="st"> </span>guess/init)
        <span class="kw">cat</span>(<span class="st">&quot;재귀방법 현재 값: &quot;</span>, init, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
        <span class="kw">return</span>(<span class="kw">find_root_recur</span>(guess, init, eps))
    }
}

<span class="kw">find_root_recur</span>(<span class="dv">612</span>, <span class="dv">10</span>)</code></pre></div>
<pre class="output"><code>재귀방법 현재 값:  35.6 
재귀방법 현재 값:  26.39551 
재귀방법 현재 값:  24.79064 
재귀방법 현재 값:  24.73869 
재귀방법 현재 값:  24.73863 
재귀방법 현재 값:  24.73863 
</code></pre>
<pre class="output"><code>[1] 24.73863
</code></pre>
</div>
</div>
<h2 id="map-reduce-apply">2. <code>Map()</code>, <code>Reduce()</code> 함수와 <code>*apply()</code> 함수 가족 <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></h2>
<p>함수를 인자로 받는 함수를 고차함수(High-order function)라고 부른다. 대표적으로 <code>Map()</code>, <code>Reduce()</code>가 있다. 숫자 하나가 아닌 벡터에 대한 제곱근을 구하기 위해서 <code>Map</code> 함수를 사용한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 제곱근 함수 -------------------------------------------</span>

find_root_recur &lt;-<span class="st"> </span>function(guess, init, <span class="dt">eps =</span> <span class="dv">10</span>^(-<span class="dv">10</span>)){
    if(<span class="kw">abs</span>(init**<span class="dv">2</span> -<span class="st"> </span>guess) &lt;<span class="st"> </span>eps){
        <span class="kw">return</span>(init)
    } else{
        init &lt;-<span class="st"> </span><span class="dv">1</span>/<span class="dv">2</span> *(init +<span class="st"> </span>guess/init)
        <span class="kw">return</span>(<span class="kw">find_root_recur</span>(guess, init, eps))
    }
}

<span class="co"># 벡터에 대한 제곱근 계산 </span>

numbers &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">16</span>, <span class="dv">25</span>, <span class="dv">36</span>, <span class="dv">49</span>, <span class="dv">64</span>, <span class="dv">81</span>)
<span class="kw">Map</span>(find_root_recur, numbers, <span class="dt">init=</span><span class="dv">1</span>, <span class="dt">eps =</span> <span class="dv">10</span>^-<span class="dv">10</span>)</code></pre></div>
<pre class="output"><code>[[1]]
[1] 4

[[2]]
[1] 5

[[3]]
[1] 6

[[4]]
[1] 7

[[5]]
[1] 8

[[6]]
[1] 9
</code></pre>
<p>숫자 하나를 받는 함수가 아니라, 벡터를 인자로 받아 제곱근을 계산하는 함수를 작성할 경우 함수 내부에서 함수를 인자로 받을 수 있도록 <code>Map</code> 함수를 활용한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># `Map` 벡터 제곱근 계산</span>

find_vec_root_recur &lt;-<span class="st"> </span>function(numbers, init, <span class="dt">eps =</span> <span class="dv">10</span>^(-<span class="dv">10</span>)){
    <span class="kw">return</span>(<span class="kw">Map</span>(find_root_recur, numbers, init, eps))
}

numbers_z &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">9</span>, <span class="dv">16</span>, <span class="dv">25</span>, <span class="dv">49</span>, <span class="dv">121</span>)
<span class="kw">find_vec_root_recur</span>(numbers_z, <span class="dt">init=</span><span class="dv">1</span>, <span class="dt">eps=</span><span class="dv">10</span>^(-<span class="dv">10</span>))</code></pre></div>
<pre class="output"><code>[[1]]
[1] 3

[[2]]
[1] 4

[[3]]
[1] 5

[[4]]
[1] 7

[[5]]
[1] 11
</code></pre>
<p>이러한 패턴이 많이 활용되어 <code>*apply</code> 함수가 있어, 이전에 많이 사용했을 것이다. 벡터를 인자로 먼저 넣고, 함수명을 두번째 인자로 넣고, 함수에 들어갈 매개변수를 순서대로 쭉 나열하여 <code>lapply</code>, <code>sapply</code> 함수에 넣는다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># `lapply` 활용 제급근 계산</span>

<span class="kw">lapply</span>(numbers_z, find_root_recur, <span class="dt">init=</span><span class="dv">1</span>, <span class="dt">eps=</span><span class="dv">10</span>^(-<span class="dv">10</span>))</code></pre></div>
<pre class="output"><code>[[1]]
[1] 3

[[2]]
[1] 4

[[3]]
[1] 5

[[4]]
[1] 7

[[5]]
[1] 11
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sapply</span>(numbers_z, find_root_recur, <span class="dt">init=</span><span class="dv">1</span>, <span class="dt">eps=</span><span class="dv">10</span>^(-<span class="dv">10</span>))</code></pre></div>
<pre class="output"><code>[1]  3  4  5  7 11
</code></pre>
<p><code>Reduce</code> 함수도 삶을 편안하게 할 수 있는, 루프를 회피하는 또다른 방법이다. 이름에서 알 수 있듯이 <code>numbers_z</code> 벡터 원소 각각에 대해 해당 연산작업 <code>+</code>, <code>%%</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Reduce ----------------------------------------------</span>
numbers_z</code></pre></div>
<pre class="output"><code>[1]   9  16  25  49 121
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Reduce</span>(<span class="st">`</span><span class="dt">+</span><span class="st">`</span>, numbers_z)</code></pre></div>
<pre class="output"><code>[1] 220
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">numbers_z &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">10</span>,<span class="dv">7</span>,<span class="dv">5</span>)
<span class="kw">Reduce</span>(<span class="st">`</span><span class="dt">%%</span><span class="st">`</span>, numbers_z)</code></pre></div>
<pre class="output"><code>[1] 3
</code></pre>
<h2 id="functional-programming-purrr">3. <code>purrr</code> 팩키지</h2>
<p><code>*apply</code> 계열 함수는 각각의 자료형에 맞춰 기억하기가 쉽지 않아, 매번 도움말을 찾아 확인하고 코딩을 해야하는 번거러움이 많다. 데이터 분석을 함수형 프로그래밍 패러다임으로 실행하도록 <code>purrr</code> 팩키지가 개발되었다. 이를 통해 데이터 분석 작업이 수월하게 되어 저녁이 있는 삶이 길어질 것으로 기대된다.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://www.brodrigues.co/fput/">Bruno Rodrigues(2016), “Functional programming and unit testing for data munging with R”, LeanPub, 2016-12-23</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="https://jennybc.github.io/purrr-tutorial/index.html"><code>purrr</code> tutorial: Lessons and Examples</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="https://github.com/jennybc/purrr-tutorial/"><code>purrr</code> tutorial GitHub Webpage</a><a href="#fnref3">↩</a></p></li>
</ol>
</div>
        </div>
      </div>
      </article>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="https://github.com/swcarpentry/lesson-template">Source</a>
        <a class="label swc-blue-bg" href="mailto:admin@software-carpentry.org">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    
      ga('create', 'UA-37305346-2', 'auto');
      ga('send', 'pageview');
    
    </script>
  </body>
</html>
