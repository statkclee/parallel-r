<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: 데이터 과학</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="Software Carpentry Blog" href="http://software-carpentry.org/feed.xml"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="http://software-carpentry.org" title="Software Carpentry">
          <img alt="Software Carpentry banner" src="img/software-carpentry-banner.png" />
        </a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <a href="index.html"><h1 class="title">데이터 과학</h1></a>
          <h2 class="subtitle">R 스케일-아웃 성능향상</h2>
          <section class="objectives panel panel-warning">
<div class="panel-heading">
<h2 id="학습-목표"><span class="glyphicon glyphicon-certificate"></span>학습 목표</h2>
</div>
<div class="panel-body">
<ul>
<li>R 스케일-아웃 전략을 통한 성능향상에 대해 살펴본다.</li>
<li></li>
</ul>
</div>
</section>
<h2 id="병렬-프로그래밍을-위한-하드웨어-환경">1. 병렬 프로그래밍을 위한 하드웨어 환경</h2>
<p><img src="fig/parallel-hw-arch.png" alt="병렬컴퓨팅 하드웨어 아키텍처" width="70%"></p>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h3 id="병렬-프로그래밍-개념과-용어-정의"><span class="glyphicon glyphicon-pushpin"></span>병렬 프로그래밍 개념과 용어 정의</h3>
</div>
<div class="panel-body">
<ul>
<li><strong>암시적 병렬성(Implicit Parallelism)</strong> : 병렬 연산처리과정이 사용자로부터 숨겨서 보이지 않음. 예를 들어, 멀티스레드(Multi-thread BLAS)가 여기에 해당된다. 스레드란 한 메시지 처리를 완료한데 필요한 일련의 작업 혹은 프로그램 흐름을 지칭한다.</li>
<li><strong>명시적 병렬성(Explicit Parallelism)</strong> : 명시적으로 작업을 수행하기 때문에 작업조합이 필요하다. <code>parallel</code> 팩키지 <code>mclapply()</code>가 여기에 해당된다.</li>
<li><strong>처치 곤란한 만큼 동시작업이 가능한 병렬(embarrassingly parallel) 혹은 느슨한 결합(Loosely Coupled:)</strong> : 다소 반어법적으로 처치 곤란할 정도로 많다는 의미가 병렬처리 작업에 대입되어, 의존성이 거의 없어 임의 순서나 방법으로 처리가 가능한 작업이 여기에 해당된다.</li>
<li><strong>밀착결합(Tightly Coupled:)</strong> : 느슨한 결합의 반대의 경우로 컴퓨팅 계산작업에 많은 의존성을 갖는 경우가 해당된다.</li>
</ul>
</div>
</aside>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h3 id="벽걸이-시간과-속도향상과-암달의-법칙"><span class="glyphicon glyphicon-pushpin"></span>벽걸이 시간과 속도향상과 암달의 법칙</h3>
</div>
<div class="panel-body">
<p>병렬 프로그래밍에서 <strong>벽걸이 시간(wallclock time)</strong> 이 중요한데 작업시작과 작업종류를 측정한다. <a href="https://ko.wikipedia.org/wiki/암달의_법칙">암달의 법칙(Amdahl’s law)</a>은 암달의 저주로도 불리며, 프로그램을 100% 병렬처리가 가능하도록 만들고 프로세서를 늘리면 성능이 무한대로 가능하지만, 현실적으로 100% 병렬 프로그램을 작성할 수는 없다. 예를 들어, 95% 병렬처리가 가능하다고 가정하면, 무한대 프로세서를 사용해도 최대 20배로 <strong>속도향상(speedup)</strong> 이 제한된다.</p>
</div>
</aside>
<h2 id="병렬-프로그래밍을-r-팩키지-툴체인">2. 병렬 프로그래밍을 R 팩키지 툴체인</h2>
<p><a href="http://cran.r-project.org/web/views/HighPerformanceComputing.html">CRAN Task View - High-Performance and Parallel Computing with R</a> 사이트에 가면 R에서 바라본 다양한 고성능 슈퍼컴퓨팅 관련 작업이 일목요연하게 정리되어 있다.</p>
<h3 id="공유-메모리-모형을-활용한-r-병렬-컴퓨팅">2.1. 공유 메모리 모형을 활용한 R 병렬 컴퓨팅</h3>
<p><code>parallel</code>은 독립적으로 서로 다른 사람들이 개발한 <code>snow</code> 와 <code>multicore</code>를 합친 것이다. <code>multicore</code>는 <strong>포크(fork)</strong> 를 사용하는 반면에 <code>snow</code>는 소켓(socket)을 사용한다. 윈도우에서는 지원이 제한되는 경우가 있기 때문에, 가능하면 리눅스 계열을 운영체제를 사용한다.</p>
<h4 id="parallel-계열">2.1.1. <code>parallel</code> 계열</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#-------------------------------------------------------------------------</span>
<span class="co"># 1.1. multicore</span>
<span class="co">#-------------------------------------------------------------------------</span>
x &lt;-<span class="st"> </span><span class="kw">lapply</span> (<span class="dv">1</span>:<span class="dv">10</span> , sqrt )
<span class="kw">library</span>(parallel)
x.mc &lt;-<span class="st"> </span><span class="kw">mclapply</span>(<span class="dv">1</span>:<span class="dv">10</span>, sqrt)
<span class="kw">all.equal</span> (x.mc ,x)

<span class="kw">simplify2array</span>(<span class="kw">mclapply</span>(<span class="dv">1</span>:<span class="dv">10</span> , function(i) <span class="kw">Sys.getpid</span>(), <span class="dt">mc.cores=</span><span class="dv">1</span>))

<span class="co">#-------------------------------------------------------------------------</span>
<span class="co"># 1.2. snow</span>
<span class="co">#-------------------------------------------------------------------------</span>
<span class="co"># ## Set up the worker processes</span>
cl &lt;-<span class="st"> </span><span class="kw">makeCluster</span>(<span class="kw">detectCores</span>())
cl
<span class="co"># socket cluster with 4 nodes on host</span>
<span class="kw">parSapply</span>(cl, <span class="dv">1</span>:<span class="dv">5</span>, sqrt)
<span class="kw">stopCluster</span>(cl)</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">팩키지</th>
<th align="left">함수</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">공통</td>
<td align="left"><code>detectCores()</code>, <code>splitIndices()</code></td>
</tr>
<tr class="even">
<td align="left"><code>multicore</code></td>
<td align="left"><code>mclapply()</code>, <code>mcmapply()</code>, <code>mcparallel()</code>, <code>mccollect()</code></td>
</tr>
<tr class="odd">
<td align="left"><code>snow</code></td>
<td align="left"><code>makeCluster()</code>, <code>stopCluster()</code>, <code>parLapply()</code>, <code>parSapply()</code></td>
</tr>
</tbody>
</table>
<h4 id="foreach-계열">2.1.2. <code>foreach</code> 계열</h4>
<p>지금은 마이크로소프트에 인수된 Revolution Analytics에서 개발된 <code>foreach</code> 팩키지로 일종의 통합 인터페이스로 백엔드에 <code>doMC</code>, <code>doMPI</code>, <code>doParallel</code>, <code>doRedis</code>, <code>doRNG</code>, <code>doSNOW</code>를 두고 통합된 인터페이스를 제공하려고 한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(foreach)
### Example 1
<span class="kw">foreach</span>(<span class="dt">i=</span><span class="dv">1</span>:<span class="dv">3</span>) %do%<span class="st"> </span><span class="kw">sqrt</span>(i)
### Example 2
n &lt;-<span class="st"> </span><span class="dv">50</span>
reps &lt;-<span class="st"> </span><span class="dv">100</span>

x &lt;-<span class="st"> </span><span class="kw">foreach</span>(<span class="dt">i=</span><span class="dv">1</span>:reps) %do%<span class="st"> </span>{
  <span class="kw">sum</span>(<span class="kw">rnorm</span>(n, <span class="dt">mean=</span>i)) /<span class="st"> </span>(n*reps)
}</code></pre></div>
<h4 id="공유메모리-분산컴퓨팅-사례-제곱근">2.2. 공유메모리 분산컴퓨팅 사례 – 제곱근</h4>
<p>윈도우에서 <code>mclapply()</code>는 코어를 하나만 제공하기 때문에 리눅스나 맥에서 수행하다. <code>mclapply</code>, <code>parSapply</code>, <code>foreach</code>를 사용해서 1에서 100,00까지 제곱근을 계산을 수행하고 기준정보 벤치마킹 작업을 수행한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(parallel)
<span class="kw">library</span>(doParallel)
<span class="kw">library</span>(rbenchmark)

## 환경설정
n &lt;-<span class="st"> </span><span class="dv">100000</span>
ncores &lt;-<span class="st"> </span><span class="dv">7</span>

cl &lt;-<span class="st"> </span><span class="kw">makeCluster</span>(ncores)
<span class="kw">registerDoParallel</span>(cl)

## 병렬처리 작업
f &lt;-<span class="st"> </span>function(n) <span class="kw">simplify2array</span>(<span class="kw">mclapply</span>(<span class="dv">1</span>:n, sqrt, <span class="dt">mc.cores=</span>ncores))
g &lt;-<span class="st"> </span>function(n) <span class="kw">parSapply</span>(cl, <span class="dv">1</span>:n, sqrt)
h &lt;-<span class="st"> </span>function(n, ncores)
{
  <span class="kw">foreach</span>(<span class="dt">i=</span><span class="dv">1</span>:ncores, <span class="dt">.combine=</span>c) %dopar%
<span class="st">  </span>{
    roots &lt;-<span class="st"> </span><span class="kw">numeric</span>(n/ncores)
    for (j in <span class="dv">1</span>:(n/ncores))
      roots[j] &lt;-<span class="st"> </span><span class="kw">sqrt</span>(i*j)
    roots
  }
}
## 벤치마킹 정보 비교
<span class="kw">benchmark</span>(<span class="dt">mclapply=</span><span class="kw">f</span>(n), <span class="dt">parSapply=</span><span class="kw">g</span>(n), <span class="dt">foreach=</span><span class="kw">h</span>(n, ncores),
          <span class="dt">columns=</span><span class="kw">c</span>(<span class="st">&quot;test&quot;</span>, <span class="st">&quot;replications&quot;</span>, <span class="st">&quot;elapsed&quot;</span>, <span class="st">&quot;relative&quot;</span>))

<span class="kw">stopCluster</span>(cl)</code></pre></div>
<p>작업수행결과 <code>foreach</code>가 가장 좋은 성능을 보이고 있다. 맥에서 7코어를 사용해서 작업을 수행한 것이다.</p>
<pre class="output"><code>       test replications elapsed relative
3   foreach          100   2.013    1.000
1  mclapply          100   8.394    4.170
2 parSapply          100   6.660    3.308</code></pre>
<h4 id="공유메모리-분산컴퓨팅-사례-몬티홀-퀴즈쇼">2.3. 공유메모리 분산컴퓨팅 사례 – 몬티홀 퀴즈쇼</h4>
<p><a href="https://ko.wikipedia.org/wiki/몬티_홀_문제">몬티 홀 문제</a>는 미국의 TV 게임쇼(Let’s make a deal)에서 유래한 퍼즐이다. 세 개의 문 중에 하나를 선택하여 문 뒤에 있는 선물을 가질 수 있는 게임쇼에 참가했다. 한 문 뒤에는 자동차가 있고, 나머지 두 문 뒤에는 염소가 있다. 이때 어떤 사람이 예를 들어 1번 문을 선택했을 때, 게임쇼 진행자는 3번 문을 열어 문뒤에 염소가 있음을 보여주면서 1번 대신 2번을 선택하겠냐고 물었다. 참가자가 자동차를 가지려할 때 원래 선택했던 번호를 바꾸는 것이 유리할까? 이때 진행자는 자동차와 염소가 어떤 문에 있는지 알고 있기 때문에, 진행자가 자동차가 있는 문을 여는 일은 절대 발생하지 않는다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lets_make_a_deal &lt;-<span class="st"> </span>function()
{
  prize_door &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span>:<span class="dv">3</span>, <span class="dt">size=</span><span class="dv">1</span>)
  first_selection &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span>:<span class="dv">3</span>, <span class="dt">size=</span><span class="dv">1</span>)
  ### 항상 최초 선택을 바꾼다고 설정한다.
  if (prize_door ==<span class="st"> </span>first_selection)
    <span class="kw">return</span>(<span class="st">&quot;lose&quot;</span>)
  else
    <span class="kw">return</span>(<span class="st">&quot;win&quot;</span>)
}

wincount &lt;-<span class="st"> </span>function(winlosevec) <span class="kw">sum</span>(winlosevec==<span class="st">&quot;win&quot;</span>)

<span class="kw">library</span>(parallel)
n &lt;-<span class="st"> </span><span class="dv">1000000</span>

<span class="kw">system.time</span>({
  winlose &lt;-<span class="st"> </span><span class="kw">simplify2array</span>(<span class="kw">mclapply</span>(<span class="dv">1</span>:n, lets_make_a_deal, <span class="dt">mc.cores=</span><span class="dv">7</span>))
  <span class="kw">print</span>(<span class="kw">wincount</span>(winlose) /<span class="st"> </span>n)
})</code></pre></div>
<p>백만번 모의시험을 수행했을 때, 이론적인 확률값 <span class="math inline">\(\frac{2}{3}\)</span>에 수렴한다.</p>
<pre class="output"><code># [1] 0.666874
# 사용자  시스템 elapsed 
# 11.510   1.579   3.066 </code></pre>
<h3 id="메시지-전달을-통한-분산-r-병렬-컴퓨팅">3. 메시지 전달을 통한 분산 R 병렬 컴퓨팅</h3>
<p>분산 R 병렬 컴퓨팅을 수행해야 되는 이유는 각 범용 컴퓨터 메모리가 한정되어 있기 때문이다. 만약 데이터가 메모리보다 더 커다란 경우 메시지 전달을 통한 분산 처리를 통한 방법이 남는다.</p>
<p><code>Rmpi</code>가 대표적인 메시지 전달을 통한 분산병렬연산 작업을 수행한다. 분산된 컴퓨터는 직접 다른 컴퓨터의 메모리에 접근하여 작업을 할 수 없기 때문에 네트워크를 통해 메시지를 전달해서 공동작업을 수행한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(snow)
<span class="kw">library</span>(Rmpi)

cl &lt;-<span class="st"> </span><span class="kw">makeCluster</span>(<span class="dv">2</span>, <span class="dt">type=</span><span class="st">&quot;MPI&quot;</span>)
<span class="kw">clusterCall</span>(cl, function() <span class="kw">Sys.getpid</span>())
<span class="kw">clusterCall</span>(cl, runif, <span class="dv">2</span>)
<span class="kw">stopCluster</span>(cl)
<span class="kw">mpi.quit</span>()</code></pre></div>
<h3 id="r-병렬처리-두가지-접근방법">4. R 병렬처리 두가지 접근방법</h3>
<p><code>caret</code>, <code>tm</code> 팩키지가 병렬컴퓨팅을 수행하는 대표적인 R 팩키지다. 서로 독립적으로 문제를 나누어서 병렬처리가 가능한 사례를 두가지 R 기계학습에서 들 수 있다. 동일한 모형내에서 최적모형을 개발할 태, 모수를 추정해야 한다. 각 변수에 대한 모수 뿐만 아니라, 능선회귀 등을 통해 정규화를 할 경우 정규화 모수 <span class="math inline">\(\lambda\)</span> 도 추정을 해서 최적모형을 찾아낸다.</p>
<p>스파크의 힘을 빌어 SparkR로 분산처리 모형을 개발하는 방법이 하나이고, 또다른 방식을 다양한 R 병렬컴퓨팅 팩키지를 활용하여 최적모형을 찾아내는 것도 가능하다.</p>
<p><img src="fig/parallel-parameter-tuning.png" alt="CPU 성능향상" width="50%"></p>
<p>두번째 병렬처리 적용이 가능한 분야는 서로 다른 모형을 추정하여 결과값을 투표로 정해 조합하는 경우로 선형모형부터, 신경망, 나무모형, 확률숲 등 다양한 모형을 데이터 적합시키고 결과를 투표로 조합해서 산출해내는 방법이 있다. 위와 마찬가지로, 스파크의 힘을 빌어 SparkR로 분산처리 모형을 개발하는 방법이 하나이고, 또다른 방식을 다양한 R 병렬컴퓨팅 팩키지를 활용하여 최적모형을 찾아내는 것도 가능하다.</p>
<p><img src="fig/parallel-model-averaging.png" alt="CPU 성능향상" width="50%"></p>
        </div>
      </div>
      </article>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="https://github.com/swcarpentry/lesson-template">Source</a>
        <a class="label swc-blue-bg" href="mailto:admin@software-carpentry.org">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    
      ga('create', 'UA-37305346-2', 'auto');
      ga('send', 'pageview');
    
    </script>
  </body>
</html>
